
/*************************************************************
	Практическое занятие №4. Функции.
	Объявление, определение, вызов.
	Передача параметров. Возвращение значения.
	Указатели на функции
*************************************************************/
#include "other.h"

#define TASK_3

int _tmain()
{
#ifdef TASK_1
	/////////////////////////////////////////////////////////////////////////////
	// Задание 1. Ссылки.
	//Объявите ссылку на тип double. Посредством ссылки измените значение
	double val1 = 10;
	double& refVal1 = val1;
	refVal1 = 11;

	stop
	//Раскомментируйте  следующую строчку. Что следует сделать, чтобы
	//linker не выдавал ошибки при создании exe-файла. Подсказка: ref - это
	//внешняя по отношению к данному файлу ссылка!

	double& ref=val1;
	ref++; //??????????????????????
	stop

	//Раскомментируйте следующую строку. Что следует сделать, чтобы
	//компилятор не выдавал ошибки 
	const int& ref1 = 1;

	//Задан указатель:
	char c='A';
	char* pc = &c;
	//Объявите ссылку на указатель. Посредством ссылки измените
	char*& refPc = pc;
	//а) значение по адресу
	*refPc = 'B';
	//б) сам адрес
	refPc++;

	stop
#endif

#ifdef TASK_2
	//Задание 2. Отличия при передаче параметров а) по значению,
	// б) по ссылке, в) по указателю
	//Объявите и определите три функции , которые увеличивают заданное
	//с помощью параметра значение на 1 ( а) - IncByValue(),
	// б) - IncByPointer(), в) - IncByReference() ). 
	//Проверьте правильность с помощью отладчика.
	//
	//Замечание: объявления функций принято помещать в заголовочный файл
	int val =1;//значение этой переменной должно быть увеличено с помощью
				//каждой из функций на единицу
  
	val=IncByValue(val);
	IncByPointer(&val);
	IncByReference(val);
	stop


	//Задание 2а. Передача параметров c помощью указателя и по ссылке. 
	//Перегруженные имена функций.
	//Создайте функцию (функции) Swap(), которая меняет значения
	//переменных nX и nY местами. 
	// а)Функция должна принимать два указателя на int, оперируя с 
	//которыми менять значения переменных в вызывающей программе
	// б)Функция должна принимать две ссылки на int 
	//Проверьте правильность с помощью приведенного ниже фрагмента.

	int	nX = 1;
	int nY = -1;
	/*Swap(...  ,  ...);	//поменяли местами значения nX и nY с
						//помощью указателей на nX и nY
	Swap(...  ,  ...);	//а теперь обратно с помощью ссылок на nX и nY*/

	Swap(&nX,&nY);
	Swap(nX,nY);

	stop
#endif

#ifdef TASK_3

//Задание 3. Указатели на массивы в качестве аргументов.
//3a.Напишите два варианта функции печати элементов
//1. во встроенном двухмерном массиве
//2. в динамическом двухмерном массиве (обе размерности вычисляются)

//1.Например:
//int ar[N][M] = {список инициализаторов};//подумайте - как и где должны быть заданы N и M
//PrintArray(ar, ... может быть, понадобится передать еще какие-нибудь данные);

	const int rowSize = 3;
	const int colSize = 5;

	//встроенный
	int arrEmbeddded1[rowSize][colSize] = { {1,-7,0,45,11},
											{100,99,98,97,96},
											{-56,-234,1,57,8} };

	PrintArray(&arrEmbeddded1[0][0],rowSize,colSize);
	std::cout<<std::endl;

	//динамический
	int** arrDynamic1 = new int*[rowSize];
	for (int i = 0; i < rowSize;i++) {
		arrDynamic1[i] = new int[colSize];
		for (int j = 0; j < colSize;j++) {
			arrDynamic1[i][j] = arrEmbeddded1[i][j];
			}
		}
	
	stop
//3b.Напишите два варианта функции поиска минимального элемента
//1. во встроенном двухмерном массиве
//2. в динамическом двухмерном массиве (обе размерности вычисляются)

	int tmp = Min(&arrEmbeddded1[0][0], rowSize, colSize);

//1.Например:
//int ar[N][M] = {список инициализаторов};//подумайте - как и где должны быть заданы N и M
//int res = Min(ar, ... может быть, понадобится передать еще какие-нибудь данные);


//3c. Напишите функцию сравнения двух строк - MyStrCmp():
//Функция должна принимать два указателя на сравниваемые
//строки (возможно Вы должны указать компилятору, что функция
//не имеет права модифицировать содержимое строк)
//Функция должна возвращать отрицательное значение, если
//первая строка лексикографически меньше второй, 0 - если
//они равны и положительное значение, если первая строка
//больше второй.
//Замечание: при лексикографическом способе сравниваются коды символов.
//Вспомните, что признаком конца строки является нулевой байт.


//Создайте две строки для сравнения:

//Вызовите функцию сравнения

//Выведите результат сравнения с помощью cout:

stop
#endif
/*
	//Задание 4.Ссылки в качестве параметров. Передача указателя на встроенный
	//массив в качестве параметра функции.
	//Напишите две взаимодополняющие друг друга функции:
	//1.  ... DayOfYear(...)
	//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
	//в порядковый день года(возвращаемое значение)
	//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
	// (принимает год и порядковый день года в качестве параметров и должна сформировать
	// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)
	
	//Проверьте работоспособность обеих функций с помощью следующего фрагмента:
	

	//В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
	//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
	//данные приведенного ниже двухмерного массива nDayTab

	int nDayTab[2][12]={
		{31,28,31,30,31,30,31,31,30,31,30,31}, //невисокосный год
		{31,29,31,30,31,30,31,31,30,31,30,31}	};	//високосный год
	
	//Вызов функции DayOfYear
	//...


	//Проверка результата обратной функцией DayOfMonth
	//...

	stop
*/
	//Задание 5*. Создайте одномерный массив (размерность вычисляется в процессе
	//выполнения программы), заполните его значениями.
	//Напишите функцию, которая добавляет в массив новое значение только при условии,
	//что такого значения в массиве еще нет. Подсказка: при этом размер
	//массива должен увеличиться!
	//Для проверки напишите функцию, которая выводит значения всех элементов на экран


/*
	//Задание 6. Рекурсивные функции. Напишите рекурсивную функцию вычисления
	//суммы первых N натуральных чисел.



*/
/*
	//Задание 7а. Функции с переменным числом параметров.
	//Напишите функцию (дана заготовка VarArgs, не использующая
	// макросы), которая принимает переменное число аргументов
	// типа int и выводит на печать число принятых параметров и
	// их значения.
	// Признаком конца списка является нулевое значение.
	
	int nN1=5, nN2=11, nN3=4, nN4=7, nN5=-1;
	VarArgs(nN1,0);	
	VarArgs(nN1,nN2,0);	
	VarArgs(nN1,nN2,nN3,nN4,nN5,0);	
	stop


	//Задание 7б. Модифицируйте функцию 5а с помощью макросов
	// va_start, va_arg, va_end
*/




	//Задание 8. Возвращение адреса.
	//Напишите функцию, которая находит минимальное значение в массиве,
	// таким образом, чтобы ее вызов можно было использовать слева от знака 
	// равенства: *MyMin(параметры) = 0;
	
	

	return 0;
}//main

