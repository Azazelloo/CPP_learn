/*************************************************************
	Практическое занятие №3. Встроенные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/
#define	  stop __asm nop
#define TASK_7

#include <iostream>
#include <string>
#include <ctime>

int main() {

///////////////////////////////////////////////////////////////
//			Встроенные массивы                               //
///////////////////////////////////////////////////////////////
#ifdef TASK_1
	std::cout << "Task 1:\n";
	//Задание 1. Объявите трехмерный N*M*K массив и сформируйте указанные
	//значения элементов следующим образом:
	//а) проинициализируйте массив при объявлении
	int array1[3][3][3] = { { { 1, 1, 1 }, { 1, 1, 1 }, { 1, 1, 1 } }, { { 2, 2, 2 }, { 2, 2, 2 }, { 2, 2, 2 } }, { { 3, 3, 3 }, { 3, 3, 3 }, { 3, 3, 3 } } };
	//б)* объявите неинициализированный массив и присвойте значения элементам
	//	с помощью кода
	//					 |--------|		
	//				   / |3  3  3 |		
	//    			 |---------|3 |
	//			   / | 2  2  2 |3 |
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__| 
	//			  | 1  1  1 | /
	//			  |_________|
	//Средствами отладчика проверьте правильность Вашего решения.

	int array2[3][3][3];

	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			for (int k = 0; k < 3; k++) {
				array2[i][j][k] = i + 1;
				}
			}
		}
	int sum = 0;
	//в) найдите сумму элементов массива. Подумайте, как это сделать эффективно.
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			for (int k = 0; k < 3; k++) {
				sum += array2[i][j][k];
				}
			}
		}

	//г) проинициализируйте массив при определении:
	//					 |--------|		
	//				   / |3  0  0 |		
	//    			 |---------|0 |
	//			   / | 2  0  0 |0 |
	//			  |---------|0 |__|
	//			  | 1  0  0 |0 | /
	//			  | 0  0  0 |__| 
	//			  | 0  0  0 | /
	//			  |_________|

	int array3[3][3][3] = { { { 1, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 } }, { { 2, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 } }, { { 3, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 } } };

	//д)* Инициализация массивов строковыми литералами:
	//Объявите и проинициализируйте строковыми литералами два массива:
	//двухмерный массив и массив указателей. Поясните разницу в использовании
	//элементов таких массивов.

	char str1[][5] = { "str1", "str2", "str3" };
	const char* str2[] = { "str1", "str2", "str3" };
	stop
#endif
/////////////////////////////////////////////////////////////////////
//Задание 2. а) Напишите фрагмент кода, который вводит N целых чисел с помощью
//потока ввода в объявленный Вами ВСТРОЕННЫЙ одномерный массив, каждый раз
//упорядочивая полученное значение по возрастанию
// 1 1 45 -2 0 -1 345 6 10 56
const size_t N = 10;
	size_t counter = 0;
	int inpArr[N];
	int j;

#ifdef TASK_2_a
	std::cout << "Task 2a:\n";

	while (counter < N) {
		std::cin >> inpArr[counter];

		//_____сортировка вставками при каждом вводе значения
		if (counter > 0) {
			for (int i = 1; i <= counter; i++) {
				int key = inpArr[i];
				j = i - 1;
				while (j >= 0 && inpArr[j] > key) {
					inpArr[j + 1] = inpArr[j];
					j--;
					}
				inpArr[j + 1] = key;
				}
			}

		++counter;
		}
/**/
	stop

#endif
//б) Простой поиск.
//Модифицируйте предыдущее задание следующим образом:очередное значение
//вводится в массив только при условии, что там еще такого нет (то есть 
//дубли игнорируются
// -34 2 56 342 0 1 -45 1 56 4 100 12
#ifdef TASK_2_b
std::cout << "Task 2b:\n";

	int inpArrV2[N], checkVal;
	counter = 0;
	bool flag;

	while (counter < N) {
		flag = true;
		std::cin >> checkVal;

		//_______простым поиском ищем совпадения элементов массива с введенным значением
		for (int i = 0; i < counter; i++) {
			if (inpArrV2[i] == checkVal) {
				flag = false;
				break;
				}
			}

		//_____сортировка вставками при каждом вводе значения если введенное значение не совпало
		if (flag) {
			inpArrV2[counter] = checkVal;

			if (counter > 0) {
				for (int i = 1; i <= counter; i++) {
					int key = inpArrV2[i];
					j = i - 1;
					while (j >= 0 && inpArrV2[j] > key) {
						inpArrV2[j + 1] = inpArrV2[j];
						j--;
						}
					inpArrV2[j + 1] = key;
					}
				}

			++counter;
			}
		}

	stop

#endif

#ifdef TASK_3

		std::cout << "Task 3:\n";

///////////////////////////////////////////////////////////////////////////
//Задание 3*.С помощью данной заготовки напишите программу,
//которая:
//вводит строки с клавиатуры с помощью cin>>...
//в объявленный Вами двухмерный ВСТРОЕННЫЙ массив 5*80 элементов типа char;
//признаком конца ввода является символ * (то есть строка - "*") или
//заполнение массива (больше свободных строк нет);
//сортировка строк в алфавитном порядке. Пояснение: крайне
//не рекомендуется для сортировки сложных объектов физически
//перемещать их в памяти. Намного эффективнее завести массив
//указателей на соответствующие строки и перемещать только
//указатели.

//Подсказка: для лексиграфического сравнения строк пользуйтесь
//функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.


//Определите необходимые значения как константы
//STOP_STRING  -  "*"	//признак "прекратить ввод"
//M  -  80	//максимальный размер одной строки
//N  -  10	//максимальное количество строк в массиве
	//Объявите двухмерный массив с именем cBuffer типа char и
	// размерностью N*M
	//Объявите массив (с именем cPointers) указателей на строки
	//размерностью N
	//Цикл ввода строк:
	//а) выведите приглашение для ввода

	//б) пока не введена строка STOP_STRING или не заполнен весь массив

	{
	//ввод строки в массив cBuffer:

	//если введена строка - признак окончания, то выйти из цикла

	//Присвойте элементу массива cPointers с индексом nIndex
	//указатель на строку с номером nIndex в массиве cBuffer


	}


	//Выдать диагностику о том, что прием строк завершен.

#define STOP_STRING "*"

	const size_t rowSymArr = 5;
	const size_t colSymArr = 80;
	size_t realSize = 0;

	char symArr[rowSymArr][colSymArr];
	char* p_symArr[rowSymArr];

	for (int i = 0; i < rowSymArr; i++) {
		std::cout << "Enter row or * for end: ";
		std::cin >> symArr[i];
		if (!strcmp(symArr[i], STOP_STRING)) break;

		p_symArr[i] = &symArr[i][0];
		++realSize;
		}

	//Теперь сортируем строки:
	std::cout << "Sort: \n";

	for (int i = 0; i < realSize - 1; i++) {
		for (int j = 0; j < realSize - i - 1; j++) {
			if (strcmp(p_symArr[j], p_symArr[j + 1]) > 0) {
				std::swap(p_symArr[j], p_symArr[j + 1]);
				}
			}
		//____вывод каждой итерации сортировки
		std::cout << "\nStep" << i << "->\n";
		for (int i = 0; i < realSize; i++) {
			for (int j = 0; j < strlen(p_symArr[i]); j++) {
				std::cout << p_symArr[i][j];
				}
			std::cout << std::endl;
			}

		}
	stop
		//Цикл сортировки строк по методу "всплывающего пузырька" в
		//порядке возрастания. На каждой итерации - промежуточная печать
		//отсортированных строк

#endif

#ifdef TASK_4

		std::cout << "Task 4:\n";

//Задание 4*. Объявление и использование указателей на многомерные
// массивы. Проинициализируйте трехмерный массив
//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
//кода, который меняет местами значения элементов четных
//и нечетных слоев:
//	было:			     |--------|
//  				   / |4  4  4 |
//					 |--------|	4 |
//				   / |3  3  3 |	4 |
//    			 |---------|3 |   |
//			   / | 2  2  2 |3 | /
//			  |---------|2 |__|
//			  | 1  1  1 |2 | /
//			  | 1  1  1 |__|
//			  | 1  1  1 | /
//			  |_________|

//	стало:			     |--------|
//  				   / |3  3  3 |
//					 |--------|	3 |
//				   / |4  4  4 |	3 |
//    			 |---------|4 |   |
//			   / | 1  1  1 |4 | /
//			  |---------|1 |__|
//			  | 2  2  2 |1 | /
//			  | 2  2  2 |__|
//			  | 2  2  2 | /
//			  |_________|
/*
for(int i=0; i<...; ...)
{
//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
... =  dArray[i];
... =  dArray[i+1];
//переставляем местами элементы i-того и i+1-ого слоев


}
*/

	double dArray[4][3][3];
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 3; j++) {
			for (int k = 0; k < 3; k++) {
				dArray[i][j][k] = i + 1;
				}
			}
		}

	for (int i = 0; i < 4; i += 2) {
		//double(*lay1)[3] = dArray[i];
		//double(*lay2)[3] = dArray[i+1];

		std::swap(dArray[i], dArray[i + 1]);
		}

	stop
#endif

#ifdef TASK_5_a
		std::cout << "Task 5a:\n";

///////////////////////////////////////////////////////////////////////////
//Задание 5а. Объявите двухмерный ВСТРОЕННЫЙ массив элементов типа char.
//Сформируйте значения элементов массива с помощью генератора случайных
//чисел таким образом, чтобы в массиве были только символы '*' и '_'


//В каждой строке "сдвиньте звездочки" в начало строки, например:
//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
//и распечатайте массив по строкам - "постройте распределение"
	srand(time(NULL));
	const size_t rowStarArr = 3;
	const size_t colStarArr = 10;

	char starArr[rowStarArr][colStarArr];
	for (int i = 0; i < rowStarArr; i++) {
		for (int j = 0; j < colStarArr; j++) {
			int randVal = rand() % (2 - 1 + 1) + 1;
			if (randVal == 1) starArr[i][j] = '*';
			else starArr[i][j] = '_';
			}
		}

	//______сдвигаем звездочки (например пузырьком)

	for (int i = 0; i < rowStarArr; i++) {
		for (int j = 0; j < colStarArr - 1; j++) {
			for (int k = 0; k < colStarArr - j - 1; k++) {
				if (starArr[i][k] == '_') {
					std::swap(starArr[i][k], starArr[i][k + 1]);
					}
				}
			}
		}

	//_____вывод в консоль

	for (int i = 0; i < rowStarArr; i++) {
		for (int j = 0; j < colStarArr; j++) {
			std::cout << starArr[i][j] << " ";
			}
		std::cout << std::endl;
		}
	stop

#endif

#ifdef TASK_5_b
		std::cout << "Task 5b:\n";
// 5б. Модифицируйте предыдущее задание следующим способом:
//После заполнения массива с помощью генератора случайных чисел
//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
//"распределение"
	srand(time(NULL));
	const size_t rowStarArr = 3;
	const size_t colStarArr = 10;

	char starArr[rowStarArr][colStarArr];
	for (int i = 0; i < rowStarArr; i++) {
		for (int j = 0; j < colStarArr; j++) {
			int randVal = rand() % (2 - 1 + 1) + 1;
			if (randVal == 1) starArr[i][j] = '*';
			else starArr[i][j] = '_';
			}
		}

	//______сдвигаем звездочки
	for (int i = 0; i < colStarArr; i++) {
		for (int j = 0; j < rowStarArr - 1; j++) {
			for (int k = 0; k < rowStarArr - j - 1; k++) {
				if (starArr[k][i] == '*') {
					std::swap(starArr[k][i], starArr[k + 1][i]);
					}
				}
			}
		}
	//_____вывод в консоль
	for (int i = 0; i < rowStarArr; i++) {
		for (int j = 0; j < colStarArr; j++) {
			std::cout << starArr[i][j] << " ";
			}
		std::cout << std::endl;
		}
	stop

#endif
///////////////////////////////////////////////////////////////
//			Динамическое выделение памяти                    //
///////////////////////////////////////////////////////////////
	//Задание 6. Создайте ДИНАМИЧЕСКИЙ двухмерный массив с размерностями,
	//вычисляемыми в процессе выполнения программы - N*M.
	//Задайте значения элементов помощью генератора случайных чисел.
	//Найдите  сумму элементов.
	//Подсказка 1: для генерации случайных чисел используйте функцию
	//стандартной библиотеки - rand() (<cstdlib>)
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
	//чисел являются «псевдослучайными», то есть при двух последовательных запусках
	//приложения Вы получаете две одинаковые последовательности значений.
	//Для того чтобы генерируемые "случайные" значения были разными при каждом 
	//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
	//и time() (<ctime>).
	//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
	//Функция time() задает эту точку отсчета, считывая текущее время
	stop
	srand(time(NULL));
	int rowSize = 5, colSize = 10;
	int minRange = -10, maxRange = 10;
	int** pArr = new int*[rowSize];

	for (int i = 0; i < rowSize; i++) {
		pArr[i] = new int[colSize];
		for (int j = 0; j < colSize; j++) {
			pArr[i][j] = rand() % (maxRange - minRange + 1) + minRange;
			}
		}
	stop

#ifdef TASK_6_a
		stop
		std::cout << "Task 6a:\n";
	//Задание 6а. В сформированном массиве отсортируйте каждую строку по
	//убыванию значений. Используйте сортировку "выбором"

	//______было
	for (int i = 0; i < rowSize; i++) {
		for (int j = 0; j < colSize; j++) {
			std::cout << pArr[i][j] << " ";
			}
		std::cout << std::endl;
		}
	std::cout << "\n\n";

	//_____сортировка строк выбором
	for (int i = 0; i < rowSize; i++) {
		for (int j = 0; j < colSize - 1; j++) {
			int min = j;
			for (int k = j + 1; k < colSize; k++) {
				if (pArr[i][k] < pArr[i][min]) {
					min = k;
					}
				}
			if (min != j) {
				std::swap(pArr[i][j], pArr[i][min]);
				}
			}
		}

	//_______стало
	for (int i = 0; i < rowSize; i++) {
		for (int j = 0; j < colSize; j++) {
			std::cout << pArr[i][j] << " ";
			}
		std::cout << std::endl;
		}
	std::cout << "\n\n";

	stop
#endif


	double* averageArr = new double[rowSize];

#ifdef TASK_6_b
	//Задание 6б. Объявите одномерный массив размерностью N.
	//Сформируйте значение i-ого элемента одномерного массива  
	//равным среднему значению элементов i-ой строки
	//двухмерного массива

	for (int i = 0; i < rowSize; i++) {
		averageArr[i] = 0;
		for (int j = 0; j < colSize; j++) {
			averageArr[i] += pArr[i][j];
			}
		averageArr[i] = averageArr[i] / colSize;
		}

	for (int i = 0; i < rowSize; i++) {
		std::cout << averageArr[i] << " ";
		}
	std::cout << "\n\n";
	stop
#endif
	//Подсказка - не забудьте освободить память!

	delete[] averageArr;

	for (int i = 0; i < rowSize; i++) {
		delete[] pArr[i];
		}
	delete[] pArr;

	stop

#ifdef TASK_7
	//Задание 7*. Реализуйте задание №3, используя не встроенные,
	//а ДИНАМИЧЕСКИЕ массивы (массив?). Так как строки могут быть разной длины,
	//эффективным решением было бы отводить под каждую строку ровно столько байтов,
	//сколько требуется для ее хранения.
	//При этом необходимые параметры (количество строк
	// сформируйте с помощью потока ввода
	//int nStringNumber;

	///////////////////////////////////////////////////////////////////////////
	//Задание 3*.С помощью данной заготовки напишите программу,
	//которая:
	//вводит строки с клавиатуры с помощью cin>>...
	//в объявленный Вами двухмерный ВСТРОЕННЫЙ массив 5*80 элементов типа char;
	//признаком конца ввода является символ * (то есть строка - "*") или
	//заполнение массива (больше свободных строк нет);
	//сортировка строк в алфавитном порядке. Пояснение: крайне
	//не рекомендуется для сортировки сложных объектов физически
	//перемещать их в памяти. Намного эффективнее завести массив
	//указателей на соответствующие строки и перемещать только
	//указатели.
	//Подсказка: для лексиграфического сравнения строк пользуйтесь
	//функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.
	//Определите необходимые значения как константы
	//STOP_STRING  -  "*"	//признак "прекратить ввод"
	//M  -  80	//максимальный размер одной строки
	//N  -  10	//максимальное количество строк в массиве
	///////////////////////////////////////////////////////////////////////////







	//Цикл ввода строк:




	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания кода первого символа





	//Освобождение занятой памяти:




#endif

return 0;
	}