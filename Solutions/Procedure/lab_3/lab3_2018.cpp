/*************************************************************
	Практическое занятие №3. Встроенные массивы.
							Динамическое выделение памяти.
							Простейшие алгоритмы сортировки и поиска.
							Сложные указатели.
							Ссылки.
*************************************************************/


#define	  stop __asm nop

int main()
{

///////////////////////////////////////////////////////////////
//			Встроенные массивы                               //
///////////////////////////////////////////////////////////////
/*
	//Задание 1. Объявите трехмерный N*M*K массив и сформируйте указанные
	//значения элементов следующим образом:
	//а) проинициализируйте массив при объявлении
	//б)* объявите неинициализированный массив и присвойте значения элементам
	//	с помощью кода
	//					 |--------|		
	//				   / |3  3  3 |		
	//    			 |---------|3 |
    //			   / | 2  2  2 |3 |
	//			  |---------|2 |__|
	//			  | 1  1  1 |2 | /
	//			  | 1  1  1 |__| 
	//			  | 1  1  1 | /
	//			  |_________|
	//Средствами отладчика проверьте правильность Вашего решения.

	//в) найдите сумму элементов массива. Подумайте, как это сделать эффективно.
	 
	//г) проинициализируйте массив при определении:
	//					 |--------|		
	//				   / |3  0  0 |		
	//    			 |---------|0 |
    //			   / | 2  0  0 |0 |
	//			  |---------|0 |__|
	//			  | 1  0  0 |0 | /
	//			  | 0  0  0 |__| 
	//			  | 0  0  0 | /
	//			  |_________|
  


	//д)* Инициализация массивов строковыми литералами:
	//Объявите и проинициализируйте строковыми литералами два массива:
	//двухмерный массив и массив указателей. Поясните разницу в использовании
	//элементов таких массивов.
*/
/////////////////////////////////////////////////////////////////////
//Задание 2. а) Напишите фрагмент кода, который вводит N целых чисел с помощью
//потока ввода в объявленный Вами ВСТРОЕННЫЙ одномерный массив, каждый раз
//упорядочивая полученное значение по возрастанию



//б) Простой поиск.
//Модифицируйте предыдущее задание следующим образом:очередное значение
//вводится в массив только при условии, что там еще такого нет (то есть 
//дубли игнорируются



/*
///////////////////////////////////////////////////////////////////////////
//Задание 3*.С помощью данной заготовки напишите программу,
//которая:
//вводит строки с клавиатуры с помощью cin>>...
//в объявленный Вами двухмерный ВСТРОЕННЫЙ массив 5*80 элементов типа char;
//признаком конца ввода является символ * (то есть строка - "*") или
//заполнение массива (больше свободных строк нет);
//сортировка строк в алфавитном порядке. Пояснение: крайне
//не рекомендуется для сортировки сложных объектов физически
//перемещать их в памяти. Намного эффективнее завести массив
//указателей на соответствующие строки и перемещать только
//указатели.

//Подсказка: для лексиграфического сравнения строк пользуйтесь
//функцией стандартной библиотеки strcmp(...), заголовочный файл <string>.


//Определите необходимые значения как константы
//STOP_STRING  -  "*"	//признак "прекратить ввод"
//M  -  80	//максимальный размер одной строки
//N  -  10	//максимальное количество строк в массиве



//Объявите двухмерный массив с именем cBuffer типа char и
// размерностью N*M


//Объявите массив (с именем cPointers) указателей на строки
//размерностью N


//Цикл ввода строк:
//а) выведите приглашение для ввода

//б) пока не введена строка STOP_STRING или не заполнен весь массив

{
//ввод строки в массив cBuffer:

//если введена строка - признак окончания, то выйти из цикла

//Присвойте элементу массива cPointers с индексом nIndex
//указатель на строку с номером nIndex в массиве cBuffer


}


//Выдать диагностику о том, что прием строк завершен.



//Теперь сортируем строки:

//Цикл сортировки строк по методу "всплывающего пузырька" в
//порядке возрастания. На каждой итерации - промежуточная печать
//отсортированных строк


*/
/*
//Задание 4*. Объявление и использование указателей на многомерные
// массивы. Проинициализируйте трехмерный массив
//double dArray[4][3][3] так, как показано на рисунке и напишите фрагмент
//кода, который меняет местами значения элементов четных
//и нечетных слоев:
//	было:			     |--------|
//  				   / |4  4  4 |
//					 |--------|	4 |
//				   / |3  3  3 |	4 |
//    			 |---------|3 |   |
//			   / | 2  2  2 |3 | /
//			  |---------|2 |__|
//			  | 1  1  1 |2 | /
//			  | 1  1  1 |__|
//			  | 1  1  1 | /
//			  |_________|

//	стало:			     |--------|
//  				   / |3  3  3 |
//					 |--------|	3 |
//				   / |4  4  4 |	3 |
//    			 |---------|4 |   |
//			   / | 1  1  1 |4 | /
//			  |---------|1 |__|
//			  | 2  2  2 |1 | /
//			  | 2  2  2 |__|
//			  | 2  2  2 | /
//			  |_________|

for(int i=0; i<...; ...)
{
//Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА РАВЕНСТВА!!!
... =  dArray[i];
... =  dArray[i+1];
//переставляем местами элементы i-того и i+1-ого слоев


}
*/
/*
///////////////////////////////////////////////////////////////////////////
//Задание 5а. Объявите двухмерный ВСТРОЕННЫЙ массив элементов типа char.
//Сформируйте значения элементов массива с помощью генератора случайных
//чисел таким образом, чтобы в массиве были только символы '*' и '_'


//В каждой строке "сдвиньте звездочки" в начало строки, например:
//было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
//стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
//и распечатайте массив по строкам - "постройте распределение"



*/


// 5б. Модифицируйте предыдущее задание следующим способом:
//После заполнения массива с помощью генератора случайных чисел
//"сдвиньте" звездочки по столбцам вниз и распечатайте полученное
//"распределение"

///////////////////////////////////////////////////////////////
//			Динамическое выделение памяти                    //
///////////////////////////////////////////////////////////////
	//Задание 6. Создайте ДИНАМИЧЕСКИЙ двухмерный массив с размерностями,
	//вычисляемыми в процессе выполнения программы - N*M.
	//Задайте значения элементов помощью генератора случайных чисел.
	//Найдите  сумму элементов.
	//Подсказка 1: для генерации случайных чисел используйте функцию
	//стандартной библиотеки - rand() (<cstdlib>)
	//Подсказка 2: На самом деле те значения, которые создаются генератором случайных
	//чисел являются «псевдослучайными», то есть при двух последовательных запусках
	//приложения Вы получаете две одинаковые последовательности значений.
	//Для того чтобы генерируемые "случайные" значения были разными при каждом 
	//запуске приложения используйте функции стандартной библиотеки srand() (<cstdlib>)
	//и time() (<ctime>).
	//Функция srand() осуществляет «привязку» начала генерации к указанному в качестве параметра значению.
	//Функция time() задает эту точку отсчета, считывая текущее время
	
	//srand( time( 0 ) );



	//Задание 6а. В сформированном массиве отсортируйте каждую строку по
	//убыванию значений. Используйте сортировку "выбором"


	//Задание 6б. Объявите одномерный массив размерностью N.
	//Сформируйте значение i-ого элемента одномерного массива  
	//равным среднему значению элементов i-ой строки
	//двухмерного массива


	//Подсказка - не забудьте освободить память!




	

/*
	//Задание 7*. Реализуйте задание №3, используя не встроенные,
	//а ДИНАМИЧЕСКИЕ массивы (массив?). Так как строки могут быть разной длины,
	//эффективным решением было бы отводить под каждую строку ровно столько байтов,
	//сколько требуется для ее хранения.
	//При этом необходимые параметры (количество строк
	// сформируйте с помощью потока ввода
	int nStringNumber;


	

  
	

  
	//Цикл ввода строк:

  


	//Цикл сортировки строк по методу "всплывающего пузырька" в
	//порядке возрастания кода первого символа

  
	
	  
		
	//Освобождение занятой памяти:




*/



	return 0;
}