#include "Header.h"
int main()
	{
	using namespace std;

	//Задание 1.Объявление класса. Создание экземпляра класса.
	//Вызов методов класса. 
	//Откройте закладку Class View - (здесь Вы увидите имена методов и
	//данных - классов Rect и MyString)
	//Обратите внимание на пиктограммы слева от имен членов класса - они
	//обозначают спецификатор доступа к каждому члену класса.

	//Какой конструктор вызывается при создании экземпляра класса?

	{
	Rect rect('a', 'b', 'c', 'd'); //автоматический конструктор
	stop
	}

	//1a. Объявите и определите конструктор с параметрами для
	//инициализации переменных класса. Создайте экземляры класса Rect
	//с помощью конструктора с параметрами. Если компилятор выдает
	//ошибку в предыдущем фрагменте, подумайте - чего ему не
	//хватает? Добейтесь отсутствия ошибок.
	//Выполняя задание с самого начала по шагам, определите:
	//в какой момент происходит вызов конструктора(какого?)?

	//Подсказка: учтите, что пользователь Вашего класса может указывать
	//в качестве параметров любые значения! Например:
	// Rect rrr(4,3,2,1);

	Rect rrr(4, 3, 2, 1);
	stop
		//1б. При конструировании объекта посредством конструктора без параметров
		//предусмотрите инициализацию переменных класса, например, нулем


		Rect r;
	stop
		//1в. Объявите, определите и вызовите метод класса InflateRect(), 
		//который увеличивает размеры прямоугольника на заданные приращения
		//(раздвигая стороны от центра - каждую сторону на свое значение).
		//Подсказка: объявить и определить методы можно не только "вручную",
		//но и с помощью Wizard-a Class View. Для этого: откройте закладку
		//ClassView окна проекта, сделайте активным класс Rect и нажмите
		//правую кнопку мыши - в появившемся контекстном меню выберите
		//Add/Add Member Function... С помощью появившейся диалоговой панели
		//"дайте указания" Wizard-у как объявить и определить метод.


		Rect rr1(1, 1, 3, 2);
	rr1.InflateRect(1, 1, 1, 1);
	stop


		//Задание 2.Перегрузка конструкторов и методов класса.
		//Конструктор копирования.

		//2а.Объявите и определите конструктор копирования в классе Rect.
		//Выполняя задание по шагам, определите, какой
		//конструктор вызывается при создании r1,r2,r3 и r4?
		//Чему равны переменные созданных объектов?
		Rect r1;
	Rect r2(1, 2, 3, 4);
	Rect r3 = r1;
	Rect r4(r2);
	stop


		//2б. Объявите и определите в классе Rect метод InflateRect(),
		  //который принимает два аргумента, по умолчанию равных 1, и
		  //раздвигает стороны прямоугольника на на заданные приращения.
		  //Для каких объектов вызывается функция InflateRect()?
		r1.InflateRect(1, 1);
	r2.InflateRect(2, 2);
	//Какая из функций InflateRect() вызывается в каждом из трех случаев?

		//r3.InflateRect(2,2,2,2);//первая
		//r3.InflateRect(3,3);// вторая
	r3.InflateRect(5);//вторая
	//r3.InflateRect(); //вторая
	stop



		//Задание 3.Спецификаторы доступа. Инкапсуляция.
		{
		Rect r;
	//Раскомментируйте следующую строку. Объясните ошибку
	//компилятора

	//int tmp = r.m_left_x; //private

	//Введите в класс Rect метод void SetAll(...),
	//который присваивают переменным класса передаваемые
	//значения. Вызовите созданный метод, проверьте корректность.
	r.SetAll(1, 11, 111, 1111);

	//Введите в класс Rect парный метод GetAll(...),
	//который "достает" значения private-переменных класса.
	//Вызовите созданный метод, проверьте корректность.
	int p1, p2, p3, p4;
	r.GetAll(p1, p2, p3, p4);
	stop
		}


		//Задание 4.Передача экземпляра класса в качестве параметра
		//функции. Возвращение объекта класса по значению. Поставив
		//остановы в конструкторе копирования или выполняя фрагмент
		//по шагам, определите: в какой момент происходит обращение
		//к конструктору копирования.
		//Создайте глобальную функцию
		// Rect BoundingRect(Rect, Rect);
		//которая принимает два объекта класса Rect по значению и
		//возвращает объект класса Rect, который является прямоугольником,
		//в который вписаны заданные прямоугольники. Как происходит
		//передача параметров и возвращение объекта класса?

		//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
		//может оказаться "ненормализованным", то есть m_left>m_right или/и
		//m_top>m_bottom

		{
		Rect r1(1, 2, 3, 4), r2(5, 6, 7, 8), r3, r4, r5;
		r3 = BoundingRect(r1, r2);

		//Задание 4а. Передача объектов по ссылке.
		//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
		//задачу, принимая параметры по ссылке
		//Вызываются ли конструкторы при передаче параметров?

		r4 = BoundingRect2(r1, r2); //конструктор копирования вызывается при присваивании результата функции объекту??

		//Задание 4б.Реализуйте ту же задачу (BoundingRect) методом класса
		r5.BoundingRect(r1, r2);
		stop
		}




	//Задание 5. Когда вызываются конструкторы и деструкторы.
	//Объявите и определите
	//явный деструктор класса. Поставьте остановы в
	//конструкторе (конструкторах) и деструкторе. Определите: когда для
	//каждого из объектов вызывается конструктор, а когда - деструктор?
	{
	Rect rr1; //конструктор
	Rect*	pR = new Rect(1, 2, 3, 7); //конструктор
	{
	Rect rr2(rr1); //конструктор копирования
	Rect arRect[2]; //конструктор (дважды)

	for (int i = 0; i < 3; i++)
		{
		static Rect rr3(i, i, i, i); //конструктор
		Rect rr4(*pR);// конструктор копирования
		Rect rr5(i, i, i, i); //конструктор??
		stop
		}//деструкторы для rr4,rr5
	}//деструктор для arrRect
	delete pR; //деструктор для pR ,rr3 деструктор по окончанию программы
	}


	//Задание 6.Конструктор + деструктор = функциональное
	// замыкание. Класс MyString
	// Посредством конструктора (конструкторов) и деструктора обеспечьте
	//корректные инициализацию и деактивацию объекта
	//C помощью остановов определите когда происходит
	//захват и освобождение памяти для строки-члена класса
	{
	MyString	str("It's my string!"); //нужно ли явно вызывать свой деструктор??
	//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
	//С помощью cout и метода GetString() распечатайте строку объекта str
	//Замечание: подумайте, как следует корректно реализовать метод GetString().
	//...
	cout << str.GetString() << endl; //только на вывод,если нужно использование то выделить память и скопировать туда результат GetString
	stop
	}

	//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
	//неприятности Вас ожидают. Попробуйте исправить положение (как?)
	{
	MyString str1("The first string!");
	MyString str2 = str1; //конструктор копирования
	stop
	}

	//6б. Реализуйте метод SetNewString, который будет заменять строку
	// на новую

	MyString str3 = "Old string.";
	stop
		str3.SetNewString("New string!");
	stop
		//Задание 7.  Решите с помощью классов следующую задачу:
		//даны две бочки известного объема. В одной бочке в начальный момент
		//времени содержится спирт (96%), в другой – вода.
		//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
		//в другую следующим способом: на каждой итерации
		//зачерпнули из первой бочки -> вылили во вторую
		//зачерпнули из второй бочки -> вылили в первую.
		//Требуется определить номер итерации, на которой концентрация спирта в
		//первой бочке станет меньше 50%.

	Bochka spirt(100, 96);
	Bochka water(100, 0);
	//...
	int counter = 0;
	while (spirt.Get_spirt_procent() > 50)
		{
		spirt.Pereliv(water); //или spirt.Pereliv(water, объем_кружки);
		stop
			water.Pereliv(spirt); // аналогично
		stop
			counter++;
		}
	stop
		return 0;
	}//end_main

