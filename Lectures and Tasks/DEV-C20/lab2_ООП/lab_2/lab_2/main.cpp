// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// Битовые поля.
#include "Header.h"

int _tmain(int argc, _TCHAR* argv[])
{
	//Задание 1.Массив объектов класса.
	{
		//Объявите и проинициализируйте массив ar из объектов
		// типа MyString. 
		const int N = 5;
		MyString arStr[N] = { MyString("String1"),MyString("String2"),MyString("String3") };

		//Проверка - печать строк-членов класса
		for (int i = 0; i < N; i++)
		{
			cout << arStr[i].GetString() << endl;
		}
		stop
			//Замените размер const int N=5; , не изменяя список инициализаторов.
	}
	stop


		//Задание 2.Массив указателей на объекты класса.
	{
		//Объявите и проинициализируйте массив arPtr из N
		//указателей на объекты типа MyString.
		const int N = 3;
		MyString* arPtr[N] = {new MyString("String11"),new MyString("String22")};
		//Печать строк-членов класса
			for (int i = 0; i < N; i++)
			{
				cout << arPtr[i]->GetString() << endl;
			}
			//Замените размер const int N=5; , не изменяя список инициализаторов.
				stop
	}



		//Задание 3.Простое наследование.Аргументы конструктора,
		// передаваемые в базовый класс.

		//Создайте иерархию классов:
		//базовый класс Shape (который описывает любую фигуру)
		//и два производных класса Rect и Circle.
		//Подумайте: какие данные и методы нужно ввести в базовый
		//и производные классы (например, любую фигуру можно сделать
		//цветной => в базовом классе можно ввести переменную, которая
		//будет определять цвет фигуры.
		//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);



		//В конструкторах производных классов предусмотрите передачу
		//параметра-цвета конструктору базового класса.
		//При создании и уничтожении объекта производного типа определите
		//последовательность вызовов конструкторов и деструкторов базового
		//и производного классов

	Rect rr(GREEN, 10, 21.7);
	Circle cc(BLUE, 5, 0, 1);


	stop
		//////////////////////////////////////////////////////////////////////

			//Задание 4.Виртуальные функции.
			//4а) Модифицируйте классы Shape,Rect и Circle:
			//добавьте в каждый класс public метод void WhereAmI().
			//Реализация каждой функции должна выводить сообщение
			//следующего вида "Now I am in class Shape(Rect или Circle)".
			//Выполните приведенный фрагмент, объясните результат.

			//4б) Сделайте метод WhereAmI() виртуальным.
			//Снова выполните приведенный фрагмент, объясните разницу.

	{
		Shape s(RED);
		Rect r(GREEN,2,3);
		Circle c(BLUE,5,1,1);


		//Метод какого класса вызывается в следующих строчках???
		s.WhereAmI();	//	??? Shape
		r.WhereAmI();	//	??? Rect
		c.WhereAmI();	//	??? Circle
		stop


		Shape* pShape = &s;
		Shape* pRect = &r;
		Shape* pCircle = &c;
		pShape->WhereAmI();	//	??? Shape
		pRect->WhereAmI();	//	??? Shape
		pCircle->WhereAmI(); //	??? Shape
		stop


			//Заполните ... согласно комментариям
			Shape& rShape = s; //псевдоним s
			Shape& rRect = r; //псевдоним r
			Shape& rCircle = c; //псевдоним c
			rShape.WhereAmI();	//вызов посредством rShape	??? Shape
			rRect.WhereAmI();	//вызов посредством	rRect	??? Shape
			rCircle.WhereAmI(); //вызов посредством rCircle	??? Shape
			stop
	}
		stop

				//////////////////////////////////////////////////////////////////////

					//Задание 5.Виртуальные деструкторы.
					//Модифицируйте классы:
					//a) введите соответствующие
					// деструкторы (без ключевого слова virtual).
					//Реализация каждого деструктора
					//должна выводить сообщение следующего вида
					// "Now I am in Shape's destructor!" или
					// "Now I am in Rect's destructor!"
					//Выполните фрагмент. Объясните результат.

					// b) Добавьте в объявление деструкторов ключевое слово virtual
					//Выполните фрагмент.Объясните разницу.


					//Подумайте: какие конструкторы вызываются в следующей строке?
						//Если в разработанных классов каких-то конструкторов
						//не хватает - реализуйте
						//Если Вы считаете, что в приведенном фрагменте чего-то
						//не хватает - добавьте
			{
				cout << endl;
				Rect r(GREEN, 2, 3); //в самом конце блока удаляется r
				Shape* ar[] = {new Shape(r), new Rect(r), new Circle(r), new Circle() };
				//Вызовите для каждого элемента массива метод WhereAmI()
				for (int i = 0; i < sizeof(ar) / sizeof(ar[0]); i++)
				{
					ar[i]->WhereAmI();
					delete ar[i];
				}
				stop
			}
				stop



					//Задание 6*. В чем заключается отличие 1) и 2)
				{
					cout << endl;
					Shape* pShapes = new Rect[10];//1)
					Rect* pRects = new Rect[10];//2)

					pShapes[0].WhereAmI();//в рект
					pRects[0].WhereAmI();//в рект
					stop
						//Попробуйте вызвать метод WhereAmI() для каждого элемента обоих массивов -
						//в чем заключается проблема???

					delete[] pShapes;
					delete[] pRects;

					//Освободите динамически захваченную память

				}



					//////////////////////////////////////////////////////////////////////

						//Задание 7.Виртуальные функции и оператор разрешения области видимости.

				{
					cout << endl;
					Rect r(GREEN, 2, 3);
					Shape* p = &r;
					p->WhereAmI();//rect
					stop

						//4a Оператор разрешения области видимости.
						//Посредством объекта r и указателя p вызовите виртуальную функцию
						//WhereAmI()класса Shape

						p->Shape::WhereAmI();//shape
					stop
				}


				//////////////////////////////////////////////////////////////////////
				
					//Задание 8.Чисто виртуальные функции.
					//Введите в базовый класс метод void Inflate(int); Подумайте:
					//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
					//Реализуйте этот метод для производных классов.

				/*	{
						Rect r(RED,1,1);
						Shape* p = &r;
						p->Inflate(5);
						stop
						Circle c(GREEN,5,0,0);
						p = &c;
						p->Inflate(5);
						stop
					}
				*/


				//////////////////////////////////////////////////////////////////////
					//Задание 9. Создайте глобальную функцию, которая будет принимать любое
					//количество указателей на строки, а возвращать объект MyString,
					//в котором строка будет конкатенацией параметров
				cout << endl;
				MyString res=StrConcatination("str1","str2","str3","end");
				stop
				////////////////////////////////////////////////////////////////////////
				/*
					//Задание 10.Объединения (union) C++. Битовые поля.
					//1.
					//Создайте следующие классы для различных представлений значений байта:
					//Bin - для двоичного представления
					//Hex - для шестнадцатерчного представления
					//Oct - для восьмеричного представления.
					//Подсказка 1: - для удобства используйте битовые поля.
					//Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
					//так как все они будут членами объединения (union).
					//2.
					//В каждом классе введите метод Show, который должен выводить значение в
					//соответствующем виде
					//3.
					//Посредством объединения MyByte предоставьте пользователю возможность манипулировать
					//одним и тем же значением по-разному:
					//а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта
					//          а также символ, соответствующий хранимому значению (если есть соответствие);
					//б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
					//			восьмеричные, двоичные цифры;
					//в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;

					MyByte byte(0x1f);
					byte.ShowHex();
					byte.ShowBin();
					//...


				*/
				return 0;
}//endmain

